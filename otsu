import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

# ------------------- Step 0: Load Images -------------------
img1 = Image.open("/boot/jpeg-home.jpg").convert("L")
img2 = Image.open("/boot/aic-home.jpg").convert("L")
img2 = img2.resize(img1.size)

arr1 = np.array(img1, dtype=np.uint8)
arr2 = np.array(img2, dtype=np.uint8)

# ------------------- Step 1: Histogram Equalization -------------------
hist, _ = np.histogram(arr1.flatten(), bins=256, range=[0,256])
cdf = np.cumsum(hist) / arr1.size
cdf_normalized = (cdf * 255).astype(np.uint8)
equalized = cdf_normalized[arr1]

# ------------------- Step 2: Gray Level Transformations -------------------
# Negative
negative = 255 - arr1
# Gamma transformation (Î³=0.5)
gamma = 0.5
c = 255 / (np.max(arr1) ** gamma)
gamma_trans = (c * (arr1 ** gamma)).astype(np.uint8)

# ------------------- Step 3: Edge Detection (Sobel + NMS) -------------------
# Sobel kernels
Gx = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])
Gy = np.array([[1,2,1],[0,0,0],[-1,-2,-1]])

h, w = arr1.shape
padded = np.pad(arr1, 1, mode="constant")
gx = np.zeros_like(arr1, dtype=float)
gy = np.zeros_like(arr1, dtype=float)
mag = np.zeros_like(arr1, dtype=float)
angle = np.zeros_like(arr1, dtype=float)

for i in range(h):
    for j in range(w):
        region = padded[i:i+3, j:j+3]
        gx[i,j] = np.sum(region * Gx)
        gy[i,j] = np.sum(region * Gy)
        mag[i,j] = np.sqrt(gx[i,j]**2 + gy[i,j]**2)
        angle[i,j] = np.arctan2(gy[i,j], gx[i,j]) * 180 / np.pi

# Normalize magnitude
mag = 255 * (mag - mag.min()) / (mag.max() - mag.min())

# Non-Maximum Suppression
edge_map = np.zeros_like(mag)
for i in range(1, h-1):
    for j in range(1, w-1):
        ang = angle[i,j]
        m = mag[i,j]
        if (0 <= ang < 22.5) or (157.5 <= ang <= 180):
            neighbors = [mag[i,j-1], mag[i,j+1]]
        elif (22.5 <= ang < 67.5):
            neighbors = [mag[i-1,j+1], mag[i+1,j-1]]
        elif (67.5 <= ang < 112.5):
            neighbors = [mag[i-1,j], mag[i+1,j]]
        else:
            neighbors = [mag[i-1,j-1], mag[i+1,j+1]]
        edge_map[i,j] = m if m >= max(neighbors) else 0

# Thresholding for binary edges
edges = (edge_map > 100).astype(np.uint8) * 255

# ------------------- Step 4: Otsu's Thresholding -------------------
freq = dict()
for i in range(h):
    for j in range(w):
        val = arr1[i,j]
        freq[val] = freq.get(val,0) + 1

pixel_count = h * w
sig_b = np.zeros(len(freq))
keys = sorted(freq.keys())
vals = [freq[k] for k in keys]

for i in range(len(keys)):
    wb = np.sum(vals[:i]) / pixel_count
    wf = np.sum(vals[i:]) / pixel_count
    if wb == 0 or wf == 0:
        continue
    mb = np.sum(np.array(keys[:i]) * np.array(vals[:i])) / np.sum(vals[:i]) if np.sum(vals[:i])>0 else 0
    mf = np.sum(np.array(keys[i:]) * np.array(vals[i:])) / np.sum(vals[i:]) if np.sum(vals[i:])>0 else 0
    sig_b[i] = wb * wf * (mb - mf)**2

optimal_threshold = keys[np.argmax(sig_b)]
otsu_img = (arr1 > optimal_threshold).astype(np.uint8) * 255

# ------------------- Step 5: Arithmetic + Logical -------------------
add_img = np.clip(arr1 + arr2, 0, 255).astype(np.uint8)
and_result = np.bitwise_and(add_img, edges.astype(np.uint8))

# ------------------- Step 6: Visualization -------------------
plt.figure(figsize=(15,12))

plt.subplot(3,3,1), plt.imshow(arr1, cmap="gray"), plt.title("Original Image"), plt.axis("off")
plt.subplot(3,3,2), plt.imshow(equalized, cmap="gray"), plt.title("Histogram Equalized"), plt.axis("off")
plt.subplot(3,3,3), plt.imshow(negative, cmap="gray"), plt.title("Negative Transform"), plt.axis("off")

plt.subplot(3,3,4), plt.imshow(gamma_trans, cmap="gray"), plt.title("Gamma Transform"), plt.axis("off")
plt.subplot(3,3,5), plt.imshow(mag, cmap="gray"), plt.title("Gradient Magnitude"), plt.axis("off")
plt.subplot(3,3,6), plt.imshow(edges, cmap="gray"), plt.title("Edge Map"), plt.axis("off")

plt.subplot(3,3,7), plt.imshow(otsu_img, cmap="gray"), plt.title(f"Otsu Thresholding (T={optimal_threshold})"), plt.axis("off")
plt.subplot(3,3,8), plt.imshow(add_img, cmap="gray"), plt.title("Image Addition"), plt.axis("off")
plt.subplot(3,3,9), plt.imshow(and_result, cmap="gray"), plt.title("Logical AND(Add,Edges)"), plt.axis("off")

plt.tight_layout()
plt.show()
